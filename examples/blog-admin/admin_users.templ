package main

import (
	"fmt"
	"net/http"
	"strconv"

	"github.com/go-playground/form/v4"
)

// Admin User List
type adminUserListPage struct{}

type adminUserListProps struct {
	User  *User
	Users []*User
	Total int
	Page  int
}

func (u adminUserListPage) Props(r *http.Request, store *Store, auth *AuthService) (adminUserListProps, error) {
	user := auth.GetUser(r)

	// Only admins can view users
	if user.Role != "admin" {
		return adminUserListProps{}, fmt.Errorf("forbidden")
	}

	page := 1
	if p := r.URL.Query().Get("page"); p != "" {
		if parsed, err := strconv.Atoi(p); err == nil && parsed > 0 {
			page = parsed
		}
	}

	limit := 20
	offset := (page - 1) * limit

	users, total, err := store.ListUsers(limit, offset)
	if err != nil {
		return adminUserListProps{}, err
	}

	return adminUserListProps{
		User:  user,
		Users: users,
		Total: total,
		Page:  page,
	}, nil
}

templ (u adminUserListPage) Page(props adminUserListProps) {
	@adminLayout("Users", props.User) {
		<div class="page-header">
			<h1>Users</h1>
			<a href={ urlFor(ctx, adminUserNewPage{}) } class="btn primary">New User</a>
		</div>
		@dataTable([]string{"Username", "Email", "Role", "Created", "Actions"}) {
			for _, user := range props.Users {
				<tr>
					<td>{ user.Username }</td>
					<td>{ user.Email }</td>
					<td>
						<span class={ "role", "role-" + user.Role }>
							{ user.Role }
						</span>
					</td>
					<td>{ user.CreatedAt.Format("Jan 2, 2006") }</td>
					<td class="actions">
						<a href={ urlFor(ctx, adminUserEditPage{}, user.ID) }>Edit</a>
						if user.ID != props.User.ID {
							<button
								class="danger"
								hx-post={ urlFor(ctx, adminUserDeletePage{}, user.ID) }
								hx-confirm="Are you sure you want to delete this user?"
								hx-target="closest tr"
								hx-swap="outerHTML"
							>
								Delete
							</button>
						}
					</td>
				</tr>
			}
		}
		if baseURL, err := urlFor(ctx, adminUserListPage{}); err == nil {
			@pagination(props.Page, (props.Total+19)/20, baseURL)
		}
	}
}

// Admin User Form (New/Edit)
type adminUserNewPage struct{}
type adminUserEditPage struct{}

type userForm struct {
	Username string `form:"username"`
	Email    string `form:"email"`
	Password string `form:"password"`
	Role     string `form:"role"`
}

func (u adminUserNewPage) ServeHTTP(w http.ResponseWriter, r *http.Request, store *Store, auth *AuthService, decoder *form.Decoder) error {
	currentUser := auth.GetUser(r)
	if currentUser.Role != "admin" {
		return fmt.Errorf("forbidden")
	}

	if r.Method == "POST" {
		var f userForm
		if err := r.ParseForm(); err != nil {
			return err
		}
		if err := decoder.Decode(&f, r.PostForm); err != nil {
			return err
		}

		// Hash password
		hash, err := HashPassword(f.Password)
		if err != nil {
			return err
		}

		// Create user
		user := &User{
			Username:     f.Username,
			Email:        f.Email,
			PasswordHash: hash,
			Role:         f.Role,
		}

		if err := store.CreateUser(user); err != nil {
			return err
		}

		// Redirect to users list
		http.Redirect(w, r, "/admin/users", http.StatusSeeOther)
		return nil
	}

	// GET - show form
	return render(w, r, userFormPage(currentUser, nil, &userForm{Role: "reader"}, ""))
}

func (u adminUserEditPage) ServeHTTP(w http.ResponseWriter, r *http.Request, store *Store, auth *AuthService, decoder *form.Decoder) error {
	currentUser := auth.GetUser(r)
	if currentUser.Role != "admin" {
		return fmt.Errorf("forbidden")
	}

	userID, _ := strconv.Atoi(r.PathValue("id"))

	user, err := store.GetUserByID(userID)
	if err != nil {
		return err
	}

	if r.Method == "POST" {
		var f userForm
		if err := r.ParseForm(); err != nil {
			return err
		}
		if err := decoder.Decode(&f, r.PostForm); err != nil {
			return err
		}

		// Update user
		user.Username = f.Username
		user.Email = f.Email
		user.Role = f.Role

		// Update password if provided
		if f.Password != "" {
			hash, err := HashPassword(f.Password)
			if err != nil {
				return err
			}
			user.PasswordHash = hash
		}

		// In a real app, you'd have an UpdateUser method
		// For now, show success
		return render(w, r, userFormPage(currentUser, user, &f, "User updated successfully"))
	}

	// GET - show form
	form := &userForm{
		Username: user.Username,
		Email:    user.Email,
		Role:     user.Role,
	}

	return render(w, r, userFormPage(currentUser, user, form, ""))
}

templ userFormPage(currentUser *User, user *User, form *userForm, message string) {
	@adminLayout(ternary(user == nil, "New User", "Edit User"), currentUser) {
		<div class="page-header">
			if user == nil {
				<h1>New User</h1>
			} else {
				<h1>Edit User</h1>
			}
		</div>
		if message != "" {
			@alert("success", message)
		}
		<form
			method="POST"
			action={ ternaryURLWithError(user == nil, ctx, adminUserNewPage{}, adminUserEditPage{}, user.ID) }
			class="user-form"
		>
			@formField("Username", "username", "text", form.Username, nil)
			@formField("Email", "email", "email", form.Email, nil)
			@formField(ternary(user == nil, "Password", "Password (leave blank to keep current)"), "password", "password", "", nil)
			@selectField("Role", "role", form.Role, map[string]string{
				"reader": "Reader",
				"author": "Author",
				"admin":  "Admin",
			}, nil)
			<button type="submit" class="btn primary">
				if user == nil {
					Create User
				} else {
					Update User
				}
			</button>
		</form>
	}
}

// Delete user handler
type adminUserDeletePage struct{}

func (u adminUserDeletePage) ServeHTTP(w http.ResponseWriter, r *http.Request, store *Store, auth *AuthService) error {
	currentUser := auth.GetUser(r)
	if currentUser.Role != "admin" {
		return fmt.Errorf("forbidden")
	}

	userID, _ := strconv.Atoi(r.PathValue("id"))

	// Can't delete yourself
	if userID == currentUser.ID {
		return fmt.Errorf("cannot delete yourself")
	}

	// In a real app, you'd have a DeleteUser method
	// For now, return success
	w.WriteHeader(http.StatusOK)
	return nil
}

// Admin Settings
type adminSettingsPage struct{}

type settingsForm struct {
	SiteName        string `form:"site_name"`
	SiteDescription string `form:"site_description"`
	AdminEmail      string `form:"admin_email"`
}

func (s adminSettingsPage) ServeHTTP(w http.ResponseWriter, r *http.Request, auth *AuthService, config *Config, decoder *form.Decoder) error {
	user := auth.GetUser(r)
	if user.Role != "admin" {
		return fmt.Errorf("forbidden")
	}

	if r.Method == "POST" {
		var f settingsForm
		if err := r.ParseForm(); err != nil {
			return err
		}
		if err := decoder.Decode(&f, r.PostForm); err != nil {
			return err
		}

		// Update config (in memory only for this example)
		config.SiteName = f.SiteName
		config.SiteDescription = f.SiteDescription
		config.AdminEmail = f.AdminEmail

		// Show success
		return render(w, r, s.Page(user, config, "Settings updated successfully"))
	}

	// GET - show form
	return render(w, r, s.Page(user, config, ""))
}

templ (s adminSettingsPage) Page(user *User, config *Config, message string) {
	@adminLayout("Settings", user) {
		<h1>Settings</h1>
		if message != "" {
			@alert("success", message)
		}
		<form method="POST" action={ urlFor(ctx, adminSettingsPage{}) } class="settings-form">
			@formField("Site Name", "site_name", "text", config.SiteName, nil)
			@formField("Site Description", "site_description", "text", config.SiteDescription, nil)
			@formField("Admin Email", "admin_email", "email", config.AdminEmail, nil)
			<button type="submit" class="btn primary">Save Settings</button>
		</form>
	}
}

// Media Library
type mediaLibraryPage struct{}

func (m mediaLibraryPage) Props(r *http.Request, auth *AuthService) (*User, error) {
	return auth.GetUser(r), nil
}

templ (m mediaLibraryPage) Page(user *User) {
	@adminLayout("Media Library", user) {
		<div class="page-header">
			<h1>Media Library</h1>
			<button
				class="btn primary"
				@click="$refs.fileInput.click()"
			>
				Upload Files
			</button>
			<input
				type="file"
				x-ref="fileInput"
				multiple
				accept="image/*"
				style="display: none"
				hx-post={ urlFor(ctx, apiMediaUploadPage{}) }
				hx-encoding="multipart/form-data"
				hx-target="#media-grid"
				hx-swap="afterbegin"
			/>
		</div>
		<div id="media-grid" class="media-grid">
			<p>Media library functionality would go here</p>
		</div>
	}
}
