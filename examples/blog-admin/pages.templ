package main

import (
	"fmt"
	"net/http"
	"strconv"

	"github.com/go-playground/form/v4"
)

// Home page
type homePage struct{}

type homePageProps struct {
	RecentPosts  []*Post
	PopularPosts []*Post
	Categories   []*Category
	User         *User
}

func (h homePage) Props(r *http.Request, store *Store, auth *AuthService) (homePageProps, error) {
	// Get recent posts
	recentPosts, _, err := store.ListPosts(PostFilter{
		Status: "published",
		Limit:  5,
		Offset: 0,
	})
	if err != nil {
		return homePageProps{}, err
	}

	// Get popular posts (simplified - just get posts with high view count)
	popularPosts, _, err := store.ListPosts(PostFilter{
		Status: "published",
		Limit:  5,
		Offset: 0,
	})
	if err != nil {
		return homePageProps{}, err
	}

	// Get categories
	categories, err := store.ListCategories()
	if err != nil {
		return homePageProps{}, err
	}

	return homePageProps{
		RecentPosts:  recentPosts,
		PopularPosts: popularPosts,
		Categories:   categories,
		User:         auth.GetUser(r),
	}, nil
}

templ (h homePage) Page(props homePageProps) {
	@layout("Home", props.User) {
		<div class="container">
			<section class="hero">
				<h1>Welcome to Structpages Blog</h1>
				<p>A powerful blog platform demonstrating advanced structpages features</p>
			</section>
			<div class="home-grid">
				<section class="recent-posts">
					<h2>Recent Posts</h2>
					for _, post := range props.RecentPosts {
						@postCard(post)
					}
				</section>
				<aside class="sidebar">
					<section class="popular-posts">
						<h3>Popular Posts</h3>
						<ul>
							for _, post := range props.PopularPosts {
								<li>
									<a href={ urlFor(ctx, postPage{}, post.Slug) }>
										{ post.Title }
									</a>
									<span class="views">{ fmt.Sprintf("%d views", post.ViewCount) }</span>
								</li>
							}
						</ul>
					</section>
					<section class="categories">
						<h3>Categories</h3>
						<ul>
							for _, cat := range props.Categories {
								<li>
									<a href={ urlFor(ctx, categoryPage{}, cat.Slug) }>
										{ cat.Name }
										<span class="count">({ fmt.Sprint(cat.PostCount) })</span>
									</a>
								</li>
							}
						</ul>
					</section>
				</aside>
			</div>
		</div>
	}
}

// Post card component
templ postCard(post *Post) {
	<article class="post-card">
		<h3>
			<a href={ urlFor(ctx, postPage{}, post.Slug) }>{ post.Title }</a>
		</h3>
		<div class="post-meta">
			<span>By { post.Author.Username }</span>
			<span>{ post.CreatedAt.Format("Jan 2, 2006") }</span>
		</div>
		<p>{ post.Excerpt }</p>
		<a href={ urlFor(ctx, postPage{}, post.Slug) } class="read-more">Read more â†’</a>
	</article>
}

// Single post page
type postPage struct{}

type postPageProps struct {
	Post         *Post
	RelatedPosts []*Post
	User         *User
}

func (p postPage) Props(r *http.Request, store *Store, auth *AuthService) (postPageProps, error) {
	slug := r.PathValue("slug")

	post, err := store.GetPostBySlug(slug)
	if err != nil {
		return postPageProps{}, err
	}

	// Only show published posts to non-authors
	user := auth.GetUser(r)
	if post.Status != "published" && (user == nil || (user.ID != post.AuthorID && user.Role != "admin")) {
		return postPageProps{}, fmt.Errorf("post not found")
	}

	// Increment view count
	go store.IncrementPostViews(post.ID)

	// Get related posts (simplified - just get posts from same category)
	var relatedPosts []*Post
	if len(post.Categories) > 0 {
		related, _, _ := store.ListPosts(PostFilter{
			Status:     "published",
			CategoryID: post.Categories[0].ID,
			Limit:      3,
			Offset:     0,
		})
		for _, p := range related {
			if p.ID != post.ID {
				relatedPosts = append(relatedPosts, p)
			}
		}
	}

	return postPageProps{
		Post:         post,
		RelatedPosts: relatedPosts,
		User:         user,
	}, nil
}

templ (p postPage) Page(props postPageProps) {
	@layout(props.Post.Title, props.User) {
		<article class="container post-single">
			<header>
				<h1>{ props.Post.Title }</h1>
				<div class="post-meta">
					<span>By { props.Post.Author.Username }</span>
					<span>{ props.Post.CreatedAt.Format("January 2, 2006") }</span>
					<span>{ fmt.Sprintf("%d views", props.Post.ViewCount) }</span>
				</div>
				if props.Post.Status == "draft" {
					@alert("warning", "This post is a draft and not yet published")
				}
			</header>
			<div class="post-content">
				@templ.Raw(props.Post.Content)
			</div>
			<footer class="post-footer">
				if len(props.Post.Categories) > 0 {
					<div class="categories">
						<strong>Categories:</strong>
						for i, cat := range props.Post.Categories {
							if i > 0 {
								<span>, </span>
							}
							<a href={ urlFor(ctx, categoryPage{}, cat.Slug) }>{ cat.Name }</a>
						}
					</div>
				}
				if len(props.Post.Tags) > 0 {
					<div class="tags">
						<strong>Tags:</strong>
						for i, tag := range props.Post.Tags {
							if i > 0 {
								<span>, </span>
							}
							<span class="tag">{ tag.Name }</span>
						}
					</div>
				}
			</footer>
			if len(props.RelatedPosts) > 0 {
				<section class="related-posts">
					<h3>Related Posts</h3>
					<div class="related-grid">
						for _, post := range props.RelatedPosts {
							@postCard(post)
						}
					</div>
				</section>
			}
		</article>
	}
}

// Category page
type categoryPage struct{}

type categoryPageProps struct {
	Category *Category
	Posts    []*Post
	Total    int
	Page     int
	User     *User
}

func (c categoryPage) Props(r *http.Request, store *Store, auth *AuthService) (categoryPageProps, error) {
	slug := r.PathValue("slug")

	category, err := store.GetCategoryBySlug(slug)
	if err != nil {
		return categoryPageProps{}, err
	}

	// Get page number from query
	page := 1
	if p := r.URL.Query().Get("page"); p != "" {
		if parsed, err := strconv.Atoi(p); err == nil && parsed > 0 {
			page = parsed
		}
	}

	limit := 10
	offset := (page - 1) * limit

	posts, total, err := store.ListPosts(PostFilter{
		Status:     "published",
		CategoryID: category.ID,
		Limit:      limit,
		Offset:     offset,
	})
	if err != nil {
		return categoryPageProps{}, err
	}

	return categoryPageProps{
		Category: category,
		Posts:    posts,
		Total:    total,
		Page:     page,
		User:     auth.GetUser(r),
	}, nil
}

templ (c categoryPage) Page(props categoryPageProps) {
	@layout(props.Category.Name, props.User) {
		<div class="container">
			<header class="category-header">
				<h1>{ props.Category.Name }</h1>
				if props.Category.Description != "" {
					<p>{ props.Category.Description }</p>
				}
				<span class="post-count">{ fmt.Sprintf("%d posts", props.Total) }</span>
			</header>
			<div class="posts-list">
				for _, post := range props.Posts {
					@postCard(post)
				}
			</div>
			if url, err := urlFor(ctx, categoryPage{}, props.Category.Slug); err == nil {
				@pagination(props.Page, (props.Total+9)/10, url)
			}
		</div>
	}
}

// Search page
type searchPage struct{}

type searchPageProps struct {
	Query   string
	Results []*Post
	Total   int
	Page    int
	User    *User
}

func (s searchPage) Props(r *http.Request, store *Store, auth *AuthService) (searchPageProps, error) {
	query := r.URL.Query().Get("q")

	// Get page number from query
	page := 1
	if p := r.URL.Query().Get("page"); p != "" {
		if parsed, err := strconv.Atoi(p); err == nil && parsed > 0 {
			page = parsed
		}
	}

	var results []*Post
	var total int

	if query != "" {
		limit := 10
		offset := (page - 1) * limit

		var err error
		results, total, err = store.ListPosts(PostFilter{
			Status: "published",
			Search: query,
			Limit:  limit,
			Offset: offset,
		})
		if err != nil {
			return searchPageProps{}, err
		}
	}

	return searchPageProps{
		Query:   query,
		Results: results,
		Total:   total,
		Page:    page,
		User:    auth.GetUser(r),
	}, nil
}

templ (s searchPage) Page(props searchPageProps) {
	@layout("Search", props.User) {
		<div class="container">
			<h1>Search</h1>
			<form method="GET" action={ urlForOrEmpty(ctx, searchPage{}) } class="search-form">
				<input
					type="search"
					name="q"
					value={ props.Query }
					placeholder="Search posts..."
					autofocus
				/>
				<button type="submit">Search</button>
			</form>
			if props.Query != "" {
				<div class="search-results">
					<h2>
						{ fmt.Sprintf("Found %d results for \"%s\"", props.Total, props.Query) }
					</h2>
					if len(props.Results) > 0 {
						<div class="posts-list">
							for _, post := range props.Results {
								@postCard(post)
							}
						</div>
						if baseURL, err := urlFor(ctx, searchPage{}); err == nil {
							@pagination(props.Page, (props.Total+9)/10, templ.SafeURL(fmt.Sprintf("%s?q=%s", baseURL, props.Query)))
						}
					} else {
						<p>No posts found matching your search.</p>
					}
				</div>
			}
		</div>
	}
}

// HTMX partial rendering for search
templ (s searchPage) Results(props searchPageProps) {
	<div class="search-results" hx-push-url={ fmt.Sprintf("/search?q=%s&page=%d", props.Query, props.Page) }>
		<h2>
			{ fmt.Sprintf("Found %d results for \"%s\"", props.Total, props.Query) }
		</h2>
		if len(props.Results) > 0 {
			<div class="posts-list">
				for _, post := range props.Results {
					@postCard(post)
				}
			</div>
			if baseURL, err := urlFor(ctx, searchPage{}); err == nil {
				@pagination(props.Page, (props.Total+9)/10, templ.SafeURL(fmt.Sprintf("%s?q=%s", baseURL, props.Query)))
			}
		} else {
			<p>No posts found matching your search.</p>
		}
	</div>
}

// Login page
type loginPage struct{}

type loginForm struct {
	Username string `form:"username"`
	Password string `form:"password"`
	Redirect string `form:"redirect"`
}

func (l loginPage) ServeHTTP(w http.ResponseWriter, r *http.Request, auth *AuthService, decoder *form.Decoder) error {
	// Already logged in?
	if auth.IsAuthenticated(r) {
		http.Redirect(w, r, "/admin", http.StatusSeeOther)
		return nil
	}

	if r.Method == "POST" {
		var f loginForm
		if err := r.ParseForm(); err != nil {
			return err
		}
		if err := decoder.Decode(&f, r.PostForm); err != nil {
			return err
		}

		_, err := auth.Login(r, f.Username, f.Password)
		if err != nil {
			// Show error
			return render(w, r, l.Page(auth.GetUser(r), &f, err.Error()))
		}

		// Redirect to admin or requested page
		redirect := f.Redirect
		if redirect == "" {
			redirect = "/admin"
		}
		http.Redirect(w, r, redirect, http.StatusSeeOther)
		return nil
	}

	// GET request - show form
	redirect := r.URL.Query().Get("redirect")
	return render(w, r, l.Page(auth.GetUser(r), &loginForm{Redirect: redirect}, ""))
}

templ (l loginPage) Page(user *User, form *loginForm, errorMsg string) {
	@layout("Login", user) {
		<div class="container">
			<div class="login-form">
				<h1>Login</h1>
				if errorMsg != "" {
					@alert("error", errorMsg)
				}
				<form method="POST" action={ urlForOrEmpty(ctx, loginPage{}) }>
					if form.Redirect != "" {
						<input type="hidden" name="redirect" value={ form.Redirect }/>
					}
					@formField("Username", "username", "text", form.Username, nil)
					@formField("Password", "password", "password", "", nil)
					<button type="submit" class="btn primary">Login</button>
				</form>
				<p class="hint">Demo credentials: admin / admin123</p>
			</div>
		</div>
	}
}

// Logout page
type logoutPage struct{}

func (l logoutPage) ServeHTTP(w http.ResponseWriter, r *http.Request, auth *AuthService) error {
	auth.Logout(r)
	http.Redirect(w, r, "/", http.StatusSeeOther)
	return nil
}
