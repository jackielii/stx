package main

import (
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/go-playground/form/v4"
)

// Admin Dashboard
type dashboard struct{}

type dashboardProps struct {
	User          *User
	TotalPosts    int
	TotalUsers    int
	TotalComments int
	RecentPosts   []*Post
	Analytics     *Analytics
}

func (d dashboard) Props(r *http.Request, store *Store, auth *AuthService) (dashboardProps, error) {
	user := auth.GetUser(r)

	// Get counts
	_, totalPosts, _ := store.ListPosts(PostFilter{Limit: 1})
	_, totalUsers, _ := store.ListUsers(1, 0)

	// Get recent posts
	recentPosts, _, _ := store.ListPosts(PostFilter{
		Limit:  5,
		Offset: 0,
	})

	// Get today's analytics
	analytics, _ := store.GetAnalytics(time.Now())

	return dashboardProps{
		User:          user,
		TotalPosts:    totalPosts,
		TotalUsers:    totalUsers,
		TotalComments: 0, // Simplified
		RecentPosts:   recentPosts,
		Analytics:     analytics,
	}, nil
}

templ (d dashboard) Page(props dashboardProps) {
	@adminLayout("Dashboard", props.User) {
		<h1>Dashboard</h1>
		<div class="stats-grid">
			@statsCard("Total Posts", fmt.Sprint(props.TotalPosts), "+5 this week")
			@statsCard("Total Users", fmt.Sprint(props.TotalUsers), "+2 this week")
			@statsCard("Page Views Today", fmt.Sprint(props.Analytics.PageViews), "")
			@statsCard("Unique Visitors", fmt.Sprint(props.Analytics.Visitors), "")
		</div>
		<div class="dashboard-grid">
			<section>
				<h2>Recent Posts</h2>
				@dataTable([]string{"Title", "Author", "Status", "Date", "Actions"}) {
					for _, post := range props.RecentPosts {
						<tr>
							<td>{ post.Title }</td>
							<td>{ post.Author.Username }</td>
							<td>
								<span class={ "status", "status-" + post.Status }>
									{ post.Status }
								</span>
							</td>
							<td>{ post.CreatedAt.Format("Jan 2, 2006") }</td>
							<td>
								<a href={ urlFor(ctx, adminPostEditPage{}, post.ID) }>Edit</a>
							</td>
						</tr>
					}
				}
			</section>
			<section>
				<h2>Top Posts Today</h2>
				if len(props.Analytics.TopPosts) > 0 {
					<ul class="top-posts">
						for _, p := range props.Analytics.TopPosts {
							<li>
								<span>{ p.PostTitle }</span>
								<span class="views">{ fmt.Sprintf("%d views", p.Views) }</span>
							</li>
						}
					</ul>
				} else {
					<p>No data available</p>
				}
			</section>
		</div>
	}
}

// Admin Post List
type adminPostListPage struct{}

type adminPostListProps struct {
	User   *User
	Posts  []*Post
	Total  int
	Page   int
	Filter PostFilter
}

func (p adminPostListPage) Props(r *http.Request, store *Store, auth *AuthService) (adminPostListProps, error) {
	user := auth.GetUser(r)

	// Parse query parameters
	page := 1
	if p := r.URL.Query().Get("page"); p != "" {
		if parsed, err := strconv.Atoi(p); err == nil && parsed > 0 {
			page = parsed
		}
	}

	filter := PostFilter{
		Status: r.URL.Query().Get("status"),
		Search: r.URL.Query().Get("search"),
		Limit:  20,
		Offset: (page - 1) * 20,
	}

	// If not admin, only show own posts
	if user.Role != "admin" {
		filter.AuthorID = user.ID
	}

	posts, total, err := store.ListPosts(filter)
	if err != nil {
		return adminPostListProps{}, err
	}

	return adminPostListProps{
		User:   user,
		Posts:  posts,
		Total:  total,
		Page:   page,
		Filter: filter,
	}, nil
}

templ (p adminPostListPage) Page(props adminPostListProps) {
	@adminLayout("Posts", props.User) {
		<div class="page-header">
			<h1>Posts</h1>
			<a href={ urlFor(ctx, adminPostNewPage{}) } class="btn primary">New Post</a>
		</div>
		<div class="filters">
			<form method="GET" action={ urlFor(ctx, adminPostListPage{}) } class="filter-form">
				<input
					type="search"
					name="search"
					placeholder="Search posts..."
					value={ props.Filter.Search }
				/>
				<select name="status">
					<option value="">All Status</option>
					<option value="draft" selected?={ props.Filter.Status == "draft" }>Draft</option>
					<option value="published" selected?={ props.Filter.Status == "published" }>Published</option>
				</select>
				<button type="submit">Filter</button>
			</form>
		</div>
		@dataTable([]string{"Title", "Author", "Status", "Published", "Views", "Actions"}) {
			for _, post := range props.Posts {
				<tr>
					<td>
						<a href={ urlFor(ctx, postPage{}, post.Slug) } target="_blank">
							{ post.Title }
						</a>
					</td>
					<td>{ post.Author.Username }</td>
					<td>
						<span class={ "status", "status-" + post.Status }>
							{ post.Status }
						</span>
					</td>
					<td>
						if post.PublishedAt != nil {
							{ post.PublishedAt.Format("Jan 2, 2006") }
						} else {
							<span class="text-muted">Not published</span>
						}
					</td>
					<td>{ fmt.Sprint(post.ViewCount) }</td>
					<td class="actions">
						<a href={ urlFor(ctx, adminPostEditPage{}, post.ID) }>Edit</a>
						if post.Status == "draft" {
							<button
								hx-post={ urlFor(ctx, apiPostPublishPage{}, post.ID) }
								hx-swap="outerHTML"
								hx-target="closest tr"
							>
								Publish
							</button>
						}
						<button
							class="danger"
							hx-post={ urlFor(ctx, adminPostDeletePage{}, post.ID) }
							hx-confirm="Are you sure you want to delete this post?"
							hx-target="closest tr"
							hx-swap="outerHTML"
						>
							Delete
						</button>
					</td>
				</tr>
			}
		}
		if baseURL, err := urlFor(ctx, adminPostListPage{}); err == nil {
			@pagination(props.Page, (props.Total+19)/20, baseURL)
		}
	}
}

// Admin Post Form (New/Edit)
type adminPostNewPage struct{}
type adminPostEditPage struct{}

type postForm struct {
	Title      string   `form:"title"`
	Slug       string   `form:"slug"`
	Content    string   `form:"content"`
	Excerpt    string   `form:"excerpt"`
	Status     string   `form:"status"`
	Categories []string `form:"categories"`
	Tags       string   `form:"tags"`
}

func (p adminPostNewPage) ServeHTTP(w http.ResponseWriter, r *http.Request, store *Store, auth *AuthService, decoder *form.Decoder) error {
	user := auth.GetUser(r)

	if r.Method == "POST" {
		var f postForm
		if err := r.ParseForm(); err != nil {
			return err
		}
		if err := decoder.Decode(&f, r.PostForm); err != nil {
			return err
		}

		// Create post
		post := &Post{
			Title:    f.Title,
			Slug:     f.Slug,
			Content:  f.Content,
			Excerpt:  f.Excerpt,
			Status:   f.Status,
			AuthorID: user.ID,
		}

		if f.Slug == "" {
			post.Slug = GenerateSlug(f.Title)
		}

		if f.Status == "published" {
			now := time.Now()
			post.PublishedAt = &now
		}

		// Parse tags
		if f.Tags != "" {
			tags := strings.Split(f.Tags, ",")
			for _, tag := range tags {
				post.Tags = append(post.Tags, Tag{Name: strings.TrimSpace(tag)})
			}
		}

		// Add categories
		for _, catID := range f.Categories {
			if id, err := strconv.Atoi(catID); err == nil {
				post.Categories = append(post.Categories, Category{ID: id})
			}
		}

		if err := store.CreatePost(post); err != nil {
			return err
		}

		// Redirect to edit page
		http.Redirect(w, r, fmt.Sprintf("/admin/posts/%d/edit", post.ID), http.StatusSeeOther)
		return nil
	}

	// GET - show form
	categories, _ := store.ListCategories()
	return render(w, r, postFormPage(user, nil, &postForm{Status: "draft"}, categories, ""))
}

func (p adminPostEditPage) ServeHTTP(w http.ResponseWriter, r *http.Request, store *Store, auth *AuthService, decoder *form.Decoder) error {
	user := auth.GetUser(r)
	postID, _ := strconv.Atoi(r.PathValue("id"))

	post, err := store.GetPostByID(postID)
	if err != nil {
		return err
	}

	// Check permission
	if user.Role != "admin" && post.AuthorID != user.ID {
		return fmt.Errorf("forbidden")
	}

	if r.Method == "POST" {
		var f postForm
		if err := r.ParseForm(); err != nil {
			return err
		}
		if err := decoder.Decode(&f, r.PostForm); err != nil {
			return err
		}

		// Update post
		post.Title = f.Title
		post.Slug = f.Slug
		post.Content = f.Content
		post.Excerpt = f.Excerpt
		post.Status = f.Status

		if f.Status == "published" && post.PublishedAt == nil {
			now := time.Now()
			post.PublishedAt = &now
		}

		// Parse tags
		post.Tags = nil
		if f.Tags != "" {
			tags := strings.Split(f.Tags, ",")
			for _, tag := range tags {
				post.Tags = append(post.Tags, Tag{Name: strings.TrimSpace(tag)})
			}
		}

		// Update categories
		post.Categories = nil
		for _, catID := range f.Categories {
			if id, err := strconv.Atoi(catID); err == nil {
				post.Categories = append(post.Categories, Category{ID: id})
			}
		}

		if err := store.UpdatePost(post); err != nil {
			return err
		}

		// Show success message (simplified - in production use flash messages)
		categories, _ := store.ListCategories()
		return render(w, r, postFormPage(user, post, &f, categories, "Post updated successfully"))
	}

	// GET - show form with existing data
	form := &postForm{
		Title:   post.Title,
		Slug:    post.Slug,
		Content: post.Content,
		Excerpt: post.Excerpt,
		Status:  post.Status,
	}

	// Build tags string
	var tags []string
	for _, tag := range post.Tags {
		tags = append(tags, tag.Name)
	}
	form.Tags = strings.Join(tags, ", ")

	// Build categories
	for _, cat := range post.Categories {
		form.Categories = append(form.Categories, fmt.Sprint(cat.ID))
	}

	categories, _ := store.ListCategories()
	return render(w, r, postFormPage(user, post, form, categories, ""))
}

// Post form template
templ postFormPage(user *User, post *Post, form *postForm, categories []*Category, message string) {
	@adminLayout(ternary(post == nil, "New Post", "Edit Post"), user) {
		<div class="page-header">
			if post == nil {
				<h1>New Post</h1>
			} else {
				<h1>Edit Post</h1>
			}
		</div>
		if message != "" {
			@alert("success", message)
		}
		<form
			method="POST"
			action={ ternaryURLWithError(post == nil, ctx, adminPostNewPage{}, adminPostEditPage{}, post.ID) }
			class="post-form"
			hx-boost="true"
		>
			<div class="form-grid">
				<div class="main-content">
					@formField("Title", "title", "text", form.Title, nil)
					@formField("Slug", "slug", "text", form.Slug, nil)
					@textareaField("Content", "content", form.Content, 20, nil)
					@textareaField("Excerpt", "excerpt", form.Excerpt, 3, nil)
				</div>
				<div class="sidebar">
					@selectField("Status", "status", form.Status, map[string]string{
						"draft":     "Draft",
						"published": "Published",
					}, nil)
					<div class="form-field">
						<label>Categories</label>
						for _, cat := range categories {
							<label class="checkbox">
								<input
									type="checkbox"
									name="categories"
									value={ fmt.Sprint(cat.ID) }
									checked?={ contains(form.Categories, fmt.Sprint(cat.ID)) }
								/>
								{ cat.Name }
							</label>
						}
					</div>
					@formField("Tags (comma separated)", "tags", "text", form.Tags, nil)
					<div class="form-actions">
						<button type="submit" class="btn primary">
							if post == nil {
								Create Post
							} else {
								Update Post
							}
						</button>
						if post != nil {
							<button
								type="button"
								hx-post={ urlFor(ctx, apiPostAutosavePage{}, post.ID) }
								hx-trigger="every 30s"
								hx-include="closest form"
								hx-swap="none"
								class="btn secondary"
							>
								Auto-save enabled
							</button>
						}
					</div>
				</div>
			</div>
		</form>
	}
}

// Delete post handler
type adminPostDeletePage struct{}

func (p adminPostDeletePage) ServeHTTP(w http.ResponseWriter, r *http.Request, store *Store, auth *AuthService) error {
	postID, _ := strconv.Atoi(r.PathValue("id"))

	post, err := store.GetPostByID(postID)
	if err != nil {
		return err
	}

	user := auth.GetUser(r)
	if user.Role != "admin" && post.AuthorID != user.ID {
		return fmt.Errorf("forbidden")
	}

	if err := store.DeletePost(postID); err != nil {
		return err
	}

	// Return empty response for HTMX to remove the row
	w.WriteHeader(http.StatusOK)
	return nil
}

// Helper functions
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
